# üöÄ Melhorias com Redis - Estoque Mestre

## üìã **Vis√£o Geral**

O Redis ser√° implementado para otimizar performance, escalabilidade e experi√™ncia do usu√°rio atrav√©s de cache inteligente e funcionalidades em tempo real.

## üéØ **1. Cache de Sess√µes e Autentica√ß√£o**

### **Problema Atual**
- Tokens JWT armazenados apenas no cliente
- Sem controle de sess√µes ativas
- Dificuldade para logout em massa
- Sem controle de dispositivos

### **Solu√ß√£o com Redis**
```typescript
// Cache de sess√µes ativas
interface UserSession {
  userId: string;
  companyId: string;
  deviceId: string;
  lastActivity: Date;
  permissions: string[];
}

// Implementa√ß√£o
@Injectable()
export class SessionService {
  async createSession(userId: string, deviceId: string): Promise<string> {
    const sessionId = generateUUID();
    const session: UserSession = {
      userId,
      companyId: user.companyId,
      deviceId,
      lastActivity: new Date(),
      permissions: user.permissions
    };
    
    await this.redis.setex(
      `session:${sessionId}`, 
      3600, // 1 hora
      JSON.stringify(session)
    );
    
    return sessionId;
  }
}
```

### **Benef√≠cios**
- ‚úÖ Controle total de sess√µes ativas
- ‚úÖ Logout em massa por empresa
- ‚úÖ Detec√ß√£o de login suspeito
- ‚úÖ Controle de dispositivos por usu√°rio

## üéØ **2. Cache de Consultas Frequentes**

### **Problema Atual**
- Consultas repetitivas ao banco
- Tempo de resposta lento para dados est√°ticos
- Sobrecarga no PostgreSQL

### **Solu√ß√£o com Redis**
```typescript
@Injectable()
export class CacheService {
  // Cache de produtos por categoria
  async getProductsByCategory(categoryId: string): Promise<Product[]> {
    const cacheKey = `products:category:${categoryId}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const products = await this.productService.findByCategory(categoryId);
    await this.redis.setex(cacheKey, 1800, JSON.stringify(products)); // 30 min
    
    return products;
  }
  
  // Cache de categorias hier√°rquicas
  async getCategoryTree(): Promise<Category[]> {
    const cacheKey = 'categories:tree';
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const tree = await this.categoryService.buildTree();
    await this.redis.setex(cacheKey, 3600, JSON.stringify(tree)); // 1 hora
    
    return tree;
  }
}
```

### **Dados para Cache**
- üì¶ **Produtos**: Por categoria, fornecedor, status
- üè¢ **Empresas**: Dados b√°sicos, configura√ß√µes
- üë• **Usu√°rios**: Perfis, permiss√µes
- üìä **Categorias**: √Årvore hier√°rquica
- üè™ **Fornecedores**: Lista, dados b√°sicos
- üìç **Localiza√ß√µes**: Estrutura hier√°rquica

## üéØ **3. Rate Limiting Inteligente**

### **Problema Atual**
- Rate limiting b√°sico por IP
- Sem diferencia√ß√£o por usu√°rio/empresa
- Sem controle de endpoints espec√≠ficos

### **Solu√ß√£o com Redis**
```typescript
@Injectable()
export class RedisRateLimitService {
  async checkRateLimit(
    key: string, 
    limit: number, 
    window: number
  ): Promise<{ allowed: boolean; remaining: number }> {
    const current = await this.redis.incr(key);
    
    if (current === 1) {
      await this.redis.expire(key, window);
    }
    
    return {
      allowed: current <= limit,
      remaining: Math.max(0, limit - current)
    };
  }
  
  // Rate limiting por usu√°rio
  async checkUserRateLimit(userId: string, endpoint: string): Promise<boolean> {
    const key = `rate_limit:user:${userId}:${endpoint}`;
    const { allowed } = await this.checkRateLimit(key, 100, 3600); // 100 req/hora
    
    return allowed;
  }
  
  // Rate limiting por empresa
  async checkCompanyRateLimit(companyId: string): Promise<boolean> {
    const key = `rate_limit:company:${companyId}`;
    const { allowed } = await this.checkRateLimit(key, 1000, 3600); // 1000 req/hora
    
    return allowed;
  }
}
```

### **Benef√≠cios**
- ‚úÖ Controle granular por usu√°rio/empresa
- ‚úÖ Diferentes limites por endpoint
- ‚úÖ Prote√ß√£o contra abuso
- ‚úÖ M√©tricas de uso em tempo real

## üéØ **4. Notifica√ß√µes em Tempo Real**

### **Problema Atual**
- Notifica√ß√µes apenas por email
- Sem notifica√ß√µes push em tempo real
- Sem hist√≥rico de notifica√ß√µes

### **Solu√ß√£o com Redis**
```typescript
@Injectable()
export class RealTimeNotificationService {
  // Publicar notifica√ß√£o
  async publishNotification(notification: Notification): Promise<void> {
    const channel = `notifications:company:${notification.companyId}`;
    await this.redis.publish(channel, JSON.stringify(notification));
    
    // Cache da notifica√ß√£o
    await this.redis.lpush(
      `notifications:user:${notification.userId}`, 
      JSON.stringify(notification)
    );
    
    // Manter apenas √∫ltimas 100 notifica√ß√µes
    await this.redis.ltrim(`notifications:user:${notification.userId}`, 0, 99);
  }
  
  // Subscrever notifica√ß√µes
  async subscribeToNotifications(companyId: string): Promise<void> {
    const channel = `notifications:company:${companyId}`;
    this.redis.subscribe(channel);
  }
  
  // Alertas autom√°ticos
  async checkLowStockAlerts(): Promise<void> {
    const lowStockProducts = await this.productService.getLowStockProducts();
    
    for (const product of lowStockProducts) {
      const alert = {
        type: 'LOW_STOCK',
        productId: product.id,
        productName: product.name,
        currentStock: product.currentStock,
        minStock: product.minStock,
        companyId: product.companyId
      };
      
      await this.publishNotification(alert);
    }
  }
}
```

### **Benef√≠cios**
- ‚úÖ Notifica√ß√µes instant√¢neas
- ‚úÖ Hist√≥rico de notifica√ß√µes
- ‚úÖ Alertas autom√°ticos
- ‚úÖ Integra√ß√£o com WebSocket

## üéØ **5. Cache de M√©tricas e Dashboards**

### **Problema Atual**
- M√©tricas calculadas a cada requisi√ß√£o
- Dashboards lentos
- Sem cache de agrega√ß√µes

### **Solu√ß√£o com Redis**
```typescript
@Injectable()
export class MetricsCacheService {
  // Cache de m√©tricas do dashboard
  async getDashboardMetrics(companyId: string): Promise<DashboardMetrics> {
    const cacheKey = `dashboard:metrics:${companyId}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const metrics = await this.calculateDashboardMetrics(companyId);
    await this.redis.setex(cacheKey, 300, JSON.stringify(metrics)); // 5 min
    
    return metrics;
  }
  
  // Cache de relat√≥rios
  async getSalesReport(companyId: string, period: string): Promise<SalesReport> {
    const cacheKey = `report:sales:${companyId}:${period}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const report = await this.generateSalesReport(companyId, period);
    await this.redis.setex(cacheKey, 1800, JSON.stringify(report)); // 30 min
    
    return report;
  }
  
  // M√©tricas em tempo real
  async updateRealTimeMetrics(companyId: string, metric: string, value: number): Promise<void> {
    const key = `metrics:realtime:${companyId}:${metric}`;
    await this.redis.incrbyfloat(key, value);
    await this.redis.expire(key, 3600); // 1 hora
  }
}
```

### **Benef√≠cios**
- ‚úÖ Dashboards instant√¢neos
- ‚úÖ Relat√≥rios pr√©-calculados
- ‚úÖ M√©tricas em tempo real
- ‚úÖ Redu√ß√£o de carga no banco

## üéØ **6. Cache de Integra√ß√µes**

### **Problema Atual**
- Dados de integra√ß√µes sempre do banco
- Sem cache de respostas de APIs externas
- Sincroniza√ß√µes lentas

### **Solu√ß√£o com Redis**
```typescript
@Injectable()
export class IntegrationCacheService {
  // Cache de dados de integra√ß√£o
  async getIntegrationData(integrationId: string, entity: string): Promise<any> {
    const cacheKey = `integration:${integrationId}:${entity}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const data = await this.fetchFromExternalAPI(integrationId, entity);
    await this.redis.setex(cacheKey, 600, JSON.stringify(data)); // 10 min
    
    return data;
  }
  
  // Cache de status de sincroniza√ß√£o
  async getSyncStatus(integrationId: string): Promise<SyncStatus> {
    const cacheKey = `sync:status:${integrationId}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const status = await this.getSyncStatusFromDB(integrationId);
    await this.redis.setex(cacheKey, 60, JSON.stringify(status)); // 1 min
    
    return status;
  }
  
  // Queue de sincroniza√ß√£o
  async queueSyncJob(integrationId: string, entity: string): Promise<void> {
    const job = {
      integrationId,
      entity,
      timestamp: new Date(),
      priority: 'normal'
    };
    
    await this.redis.lpush('sync:queue', JSON.stringify(job));
  }
}
```

### **Benef√≠cios**
- ‚úÖ Dados de integra√ß√£o em cache
- ‚úÖ Status de sincroniza√ß√£o em tempo real
- ‚úÖ Queue de jobs de sincroniza√ß√£o
- ‚úÖ Redu√ß√£o de chamadas para APIs externas

## üéØ **7. Cache de Configura√ß√µes**

### **Problema Atual**
- Configura√ß√µes sempre do banco
- Sem cache de prefer√™ncias de usu√°rio
- Configura√ß√µes de empresa lentas

### **Solu√ß√£o com Redis**
```typescript
@Injectable()
export class ConfigCacheService {
  // Cache de configura√ß√µes da empresa
  async getCompanyConfig(companyId: string): Promise<CompanyConfig> {
    const cacheKey = `config:company:${companyId}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const config = await this.companyService.getConfig(companyId);
    await this.redis.setex(cacheKey, 3600, JSON.stringify(config)); // 1 hora
    
    return config;
  }
  
  // Cache de prefer√™ncias do usu√°rio
  async getUserPreferences(userId: string): Promise<UserPreferences> {
    const cacheKey = `preferences:user:${userId}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const preferences = await this.userService.getPreferences(userId);
    await this.redis.setex(cacheKey, 1800, JSON.stringify(preferences)); // 30 min
    
    return preferences;
  }
  
  // Invalida√ß√£o de cache
  async invalidateCompanyCache(companyId: string): Promise<void> {
    const keys = await this.redis.keys(`*:${companyId}*`);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

## üìä **M√©tricas de Performance Esperadas**

### **Antes do Redis**
- ‚è±Ô∏è Tempo de resposta: 200-500ms
- üóÑÔ∏è Queries por segundo: 100-200
- üíæ Uso de mem√≥ria: 2-4GB
- üîÑ Taxa de cache hit: 0%

### **Depois do Redis**
- ‚è±Ô∏è Tempo de resposta: 50-100ms (60-80% melhoria)
- üóÑÔ∏è Queries por segundo: 500-1000 (5x melhoria)
- üíæ Uso de mem√≥ria: 1-2GB (50% redu√ß√£o)
- üîÑ Taxa de cache hit: 70-90%

## üöÄ **Plano de Implementa√ß√£o**

### **Fase 1: Infraestrutura**
1. ‚úÖ Instalar depend√™ncias Redis
2. ‚úÖ Configurar Docker Redis
3. ‚úÖ Implementar CacheModule
4. ‚úÖ Configurar vari√°veis de ambiente

### **Fase 2: Cache B√°sico**
1. ‚úÖ Cache de sess√µes JWT
2. ‚úÖ Cache de produtos e categorias
3. ‚úÖ Cache de configura√ß√µes de empresa
4. ‚úÖ Rate limiting com Redis

### **Fase 3: Cache Avan√ßado**
1. ‚úÖ Notifica√ß√µes em tempo real
2. ‚úÖ Cache de m√©tricas e dashboards
3. ‚úÖ Cache de integra√ß√µes
4. ‚úÖ Invalida√ß√£o inteligente

### **Fase 4: Otimiza√ß√£o**
1. ‚úÖ Monitoramento de cache
2. ‚úÖ M√©tricas de performance
3. ‚úÖ Tuning de TTL
4. ‚úÖ Clustering Redis

## üîß **Configura√ß√£o T√©cnica**

### **Docker Compose**
```yaml
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}

volumes:
  redis_data:
```

### **Vari√°veis de Ambiente**
```env
# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=your_secure_password
REDIS_DB=0
REDIS_TTL=3600

# Cache Configuration
CACHE_TTL_PRODUCTS=1800
CACHE_TTL_CATEGORIES=3600
CACHE_TTL_USERS=1800
CACHE_TTL_COMPANIES=3600
CACHE_TTL_METRICS=300
```

## üìà **ROI Esperado**

### **Benef√≠cios Quantitativos**
- üöÄ **60-80% redu√ß√£o** no tempo de resposta
- üí∞ **50% redu√ß√£o** no custo de infraestrutura
- üìä **5x aumento** na capacidade de requisi√ß√µes
- üîÑ **70-90% cache hit rate**

### **Benef√≠cios Qualitativos**
- üòä **Melhor experi√™ncia** do usu√°rio
- üõ°Ô∏è **Maior seguran√ßa** com controle de sess√µes
- üì± **Notifica√ß√µes em tempo real**
- üîß **Facilidade de manuten√ß√£o**

## üéØ **Pr√≥ximos Passos**

1. **Implementar infraestrutura Redis**
2. **Configurar CacheModule no NestJS**
3. **Implementar cache de sess√µes**
4. **Adicionar cache de consultas frequentes**
5. **Implementar rate limiting**
6. **Configurar notifica√ß√µes em tempo real**
7. **Adicionar m√©tricas de cache**
8. **Otimizar TTLs baseado em uso**

---

**Resultado**: Sistema 5x mais r√°pido, com melhor experi√™ncia do usu√°rio e maior escalabilidade! üöÄ
